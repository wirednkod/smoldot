<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="BABE consensus."><title>smoldot::verify::babe - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="smoldot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../smoldot/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../smoldot/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module babe</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">smoldot</a>::<wbr><a href="../index.html">verify</a>::<wbr><a class="mod" href="#">babe</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/smoldot/verify/babe.rs.html#18-523">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>BABE consensus.</p>
<p>BABE, or Blind Assignment for Blockchain Extension, is the consensus algorithm used by
Polkadot in order to determine who is authorized to generate a block.</p>
<p>Every block (with the exception of the genesis block) must contain, in its header, some data
that makes it possible to verify that it has been generated by a legitimate author.</p>
<p>References:</p>
<ul>
<li><a href="https://research.web3.foundation/en/latest/polkadot/BABE/Babe.html">https://research.web3.foundation/en/latest/polkadot/BABE/Babe.html</a></li>
</ul>
<h2 id="overview-of-babe"><a href="#overview-of-babe">Overview of BABE</a></h2>
<p>In the BABE algorithm, time is divided into non-overlapping <strong>epochs</strong>, themselves divided
into <strong>slots</strong>. How long an epoch and a slot are is determined by calling the
<code>BabeApi_configuration</code> runtime entry point.</p>
<blockquote>
<p><strong>Note</strong>: As example values, in the Polkadot genesis, a slot lasts for 6 seconds and an
epoch consists of 2400 slots (in other words, four hours).</p>
</blockquote>
<p>Every block that is produced must belong to a specific slot. This slot number can be found in
the block header, with the exception of the genesis block which is considered timeless and
doesn’t have any slot number.</p>
<p>At the moment, the current slot number is determined purely based on the slot duration (e.g.
6 seconds for Polkadot) and the local clock based on the UNIX EPOCH. The current slot
number is <code>unix_timestamp / duration_per_slot</code>. This might change in the future.</p>
<p>The first epoch (epoch number 0) starts at <code>slot_number(block #1)</code> and ends at
<code>slot_number(block #1) + slots_per_epoch</code>. The second epoch (epoch #1) starts at slot
<code>end_of_epoch_0 + 1</code>. All epochs end at <code>start_of_new_epoch + slots_per_epoch</code>. Block #0
doesn’t belong to any epoch.</p>
<p>The header of first block produced after a transition to a new epoch (including block #1) must
contain a log entry indicating the public keys that are allowed to sign blocks, alongside with
a weight for each of them, and a “randomness value”. This information does not concern the
newly-started epoch, but the one immediately after. In other words, the first block of epoch
<code>N</code> contains the information about epoch <code>N+1</code>.</p>
<blockquote>
<p><strong>Note</strong>: The way the list of authorities and their weights is determined is at the
discretion of the runtime code and is out of scope of this module, but it normally
corresponds to the list of validators and how much stake is available to them.</p>
</blockquote>
<p>In order to produce a block, one must generate, using a
<a href="https://en.wikipedia.org/wiki/Verifiable_random_function">VRF (Verifiable Random Function)</a>,
and based on the slot number, genesis hash, and aforementioned “randomness value”,
a number whose value is lower than a certain threshold.</p>
<p>The number that has been generated must be included in the header of the authored block,
alongside with the proof of the correct generation that can be verified using one of the
public keys allowed to generate blocks in that epoch. The weight associated to that public key
determines the allowed threshold.</p>
<p>The “randomness value” of an epoch <code>N</code> is calculated by combining the generated numbers of all
the blocks of the epoch <code>N - 2</code>.</p>
<h3 id="secondary-slots"><a href="#secondary-slots">Secondary slots</a></h3>
<p>While all slots can be claimed by generating a number below a certain threshold, each slot is
additionally assigned to a specific public key amongst the ones allowed. The owner of a
public key is always allowed to generate a block during the slot assigned to it.</p>
<p>The mechanism of attributing each slot to a public key is called “secondary slot claims”,
while the mechanism of generating a number below a certain threshold is called a “primary
slot claim”. As their name indicates, primary slot claims have a higher priority over
secondary slot claims.</p>
<p>Secondary slot claims are a way to guarantee that all slots can potentially lead to a block
being produced.</p>
<h3 id="chain-selection"><a href="#chain-selection">Chain selection</a></h3>
<p>The “best” block of a chain in the BABE algorithm is the one with the highest slot number.
If there exists multiple blocks on the same slot, the best block is one with the highest number
of primary slot claims. In other words, if two blocks have the same parent, but one is a
primary slot claim and the other is a secondary slot claim, we prefer the one with the primary
slot claim.</p>
<p>Keep in mind that there can still be draws in terms of primary slot claims count, in which
case the winning block is the one upon which the next block author builds upon.</p>
<h3 id="epochs-0-and-1"><a href="#epochs-0-and-1">Epochs 0 and 1</a></h3>
<p>The information about an epoch <code>N</code> is provided by the first block of the epoch <code>N-1</code>.</p>
<p>Because of this, we need to special-case epoch 0. The information about epoch 0 is contained
in the chain-wide BABE configuration found in the runtime. The first block of epoch 0 is the
block number #1. The information about epoch 1 is therefore contained in block #1.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>In order to verify a Babe block, two of the main information to pass are:</p>
<ul>
<li>The <a href="../../chain/chain_information/struct.BabeEpochInformationRef.html" title="struct smoldot::chain::chain_information::BabeEpochInformationRef"><code>chain_information::BabeEpochInformationRef</code></a> struct corresponding to the epoch the
parent block belongs to.</li>
<li>The <a href="../../chain/chain_information/struct.BabeEpochInformationRef.html" title="struct smoldot::chain::chain_information::BabeEpochInformationRef"><code>chain_information::BabeEpochInformationRef</code></a> struct of the epoch that follows.</li>
</ul>
<p>When verifying block number 1, <a href="struct.VerifyConfig.html#structfield.parent_block_epoch" title="field smoldot::verify::babe::VerifyConfig::parent_block_epoch"><code>VerifyConfig::parent_block_epoch</code></a> must be set to <code>None</code> and
<a href="struct.VerifyConfig.html#structfield.parent_block_next_epoch" title="field smoldot::verify::babe::VerifyConfig::parent_block_next_epoch"><code>VerifyConfig::parent_block_next_epoch</code></a> must be set to the definition of epoch #0 as
determined by performing runtime calls.</p>
<p>Any time verifying a block produces a <code>Some</code> in <a href="struct.VerifySuccess.html#structfield.epoch_transition_target" title="field smoldot::verify::babe::VerifySuccess::epoch_transition_target"><code>VerifySuccess::epoch_transition_target</code></a>,
which is guaranteed to be the case when verifying block number 1, an epoch transition occurs.
When verifying a child of such block, the value formerly passed as
<a href="struct.VerifyConfig.html#structfield.parent_block_next_epoch" title="field smoldot::verify::babe::VerifyConfig::parent_block_next_epoch"><code>VerifyConfig::parent_block_next_epoch</code></a> must now be passed as
<a href="struct.VerifyConfig.html#structfield.parent_block_epoch" title="field smoldot::verify::babe::VerifyConfig::parent_block_epoch"><code>VerifyConfig::parent_block_epoch</code></a>, and the value in
<a href="struct.VerifySuccess.html#structfield.epoch_transition_target" title="field smoldot::verify::babe::VerifySuccess::epoch_transition_target"><code>VerifySuccess::epoch_transition_target</code></a> becomes <a href="struct.VerifyConfig.html#structfield.parent_block_next_epoch" title="field smoldot::verify::babe::VerifyConfig::parent_block_next_epoch"><code>VerifyConfig::parent_block_next_epoch</code></a>.</p>
<p>When designing around these rules, be aware of forks: there can be multiple blocks at the same
height performing epoch transitions.</p>
<p>See also the <a href="../../chain/chain_information/index.html" title="mod smoldot::chain::chain_information"><code>crate::chain::chain_information</code></a> module for more help.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.VerifyConfig.html" title="struct smoldot::verify::babe::VerifyConfig">VerifyConfig</a></div><div class="desc docblock-short">Configuration for <a href="fn.verify_header.html" title="fn smoldot::verify::babe::verify_header"><code>verify_header</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.VerifySuccess.html" title="struct smoldot::verify::babe::VerifySuccess">VerifySuccess</a></div><div class="desc docblock-short">Information yielded back after successfully verifying a block.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.VerifyError.html" title="enum smoldot::verify::babe::VerifyError">VerifyError</a></div><div class="desc docblock-short">Failure to verify a block.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.verify_header.html" title="fn smoldot::verify::babe::verify_header">verify_header</a></div><div class="desc docblock-short">Verifies whether a block header provides a correct proof of the legitimacy of the authorship.</div></li></ul></section></div></main></body></html>