<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Transactions handling."><title>smoldot::transactions - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="smoldot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../smoldot/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../smoldot/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module transactions</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">smoldot</a>::<wbr><a class="mod" href="#">transactions</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/smoldot/transactions.rs.html#18-90">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Transactions handling.</p>
<p>This module contains everything related to the handling of transactions.</p>
<h2 id="overview"><a href="#overview">Overview</a></h2>
<p>From a thousand miles perspective, the process of including a transaction in the chain is as
follows:</p>
<ul>
<li>
<p>The transaction gets built, in other words the bytes that encode the transaction are
generated. This can be done for example through a UI, through an off-chain worker, or other. A
transaction can be either signed (i.e. have a signature attached to it) or unsigned, depending
on the action to be performed. A balance transfer, for example, generally always requires a
signature.</p>
</li>
<li>
<p>The transaction is then processed by a node, generally the node that belongs to the author
of the transaction, where it is <em>validated</em> by passing it as parameter to a runtime entry
point. See the <a href="validate/index.html" title="mod smoldot::transactions::validate"><code>validate</code></a> module for more info. The <a href="pool/index.html" title="mod smoldot::transactions::pool"><code>pool</code></a> module contains a data
structure that manages the list of pending transactions.</p>
</li>
<li>
<p>If the validation process indicates that the transaction can be propagated, it is then sent
over the peer-to-peer network to other peers. Each node that receives the transaction
similarly validates it and relays it to its own peers.</p>
</li>
<li>
<p>When a block is authored, the node that authors it picks from its pool of validated
transactions the ones to include in the block. The logic under which transactions are picked
and their ordering depends on the output of the validation. The <em>body</em> of the newly-authored
block is made of (but not exclusively) the transactions that have been included in said block.</p>
</li>
<li>
<p>When a node receives a new block, the transactions in the pool are re-validated against
this block. The validation function found in the runtime is expected to return an error if
the transaction in question is already present in the chain and should not be included again.</p>
</li>
</ul>
<h3 id="about-duplicate-transactions"><a href="#about-duplicate-transactions">About duplicate transactions</a></h3>
<p>In practice, the vast majority of the time, a given transaction can only ever be inserted
once in a chain, as the vast majority of transactions include some sort of nonce in their
encoding. In other words, once a transaction has been included in a block, trying to
re-validate that same transaction against that same block or any of its descendants will
return an error.</p>
<p>Once a transaction has been included in a block, it becomes known to everyone. If the runtime
<em>always</em> considered a certain transaction as valid, then this transaction could be repeatedly
included in the chain over and over again (and by anyone, since the transaction is public).
On a higher level, the logic of such a transaction couldn’t possibly make sense, as the reason
why transactions exist in the first place is to modify the state of the chain. In other words,
a runtime that always considers a certain transaction to be valid doesn’t make sense on a
higher level.</p>
<p>With that in mind, a Substrate/Polkadot client implementation is allowed to make two
assumptions:</p>
<ul>
<li>After a transaction has been included in a block, trying to re-validate it against that
same block or any of its descendants always yields an error.</li>
<li>The same transaction can’t possibly be included twice in the same block.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The official Substrate client, in particular, tracks transactions by their hash,
and removes from the pool any transaction from the pool after it has been included
in the best chain, without even attempting to re-validate it (but re-inserts
transactions in the pool if a block gets reverted).</p>
</blockquote>
<p>However, this is in theory not the correct behavior. A legitimate (but in practice very
uncommon) use-case for runtimes is to consider a transaction as invalid right after it has
been included, but then valid again some time in the future.</p>
<p>The specific use case is considered to be uncommon enough to not explicitly be taken into
account. The client considers that once a transaction has been considered invalid against a
certain block B, it will forever remain considered as invalid on any descendant of B, but a
client also attempts to not cache that information for <em>too long</em> through heuristics.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="light_pool/index.html" title="mod smoldot::transactions::light_pool">light_pool</a></div><div class="desc docblock-short">Transactions pool specialized for light clients usage.</div></li><li><div class="item-name"><a class="mod" href="pool/index.html" title="mod smoldot::transactions::pool">pool</a></div><div class="desc docblock-short">General-purpose transactions pool.</div></li><li><div class="item-name"><a class="mod" href="validate/index.html" title="mod smoldot::transactions::validate">validate</a></div><div class="desc docblock-short">Runtime call to obtain the transactions validity status.</div></li></ul></section></div></main></body></html>