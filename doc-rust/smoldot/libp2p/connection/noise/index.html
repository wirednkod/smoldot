<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Noise protocol libp2p layer."><title>smoldot::libp2p::connection::noise - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="smoldot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../../smoldot/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../../smoldot/index.html"><img class="rust-logo" src="../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module noise</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">smoldot</a>::<wbr><a href="../../index.html">libp2p</a>::<wbr><a href="../index.html">connection</a>::<wbr><a class="mod" href="#">noise</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../../src/smoldot/libp2p/connection/noise.rs.html#18-982">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Noise protocol libp2p layer.</p>
<p>The <a href="https://noiseprotocol.org/">noise protocol</a> is a standard framework for building
cryptographic protocols. Libp2p uses the noise protocol to provide an encryption layer on
top of which data is exchanged.</p>
<h2 id="protocol-details"><a href="#protocol-details">Protocol details</a></h2>
<p>Libp2p uses <a href="https://noiseexplorer.com/patterns/XX/">the XX pattern</a>. The handshake consists
of three packets:</p>
<ul>
<li>The initiator generates an ephemeral key pair and sends the public key to the responder.</li>
<li>The responder generates its own ephemeral key pair and sends the public key to the
initiator. Afterwards, the responder derives a shared secret and uses it to encrypt all
further communications. Now encrypted, the responder also sends back its static noise public
key (represented with the <a href="struct.NoiseKey.html" title="struct smoldot::libp2p::connection::noise::NoiseKey"><code>NoiseKey</code></a> type of this module), its libp2p public key, and a
signature of the static noise public key made using its libp2p private key.</li>
<li>The initiator, after having received the ephemeral key from the remote, derives the same
shared secret. It sends its own static noise public key, libp2p public key, and signature.</li>
</ul>
<p>After these three packets, the initiator and responder derive another shared secret using
both the static and ephemeral keys, which is then used to encrypt communications. Note that
the libp2p key isn’t used in the key derivation.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>While this is out of scope of this module, the noise protocol must typically first be
negotiated using the <em>multistream-select</em> protocol. The name of the protocol is given by
the <a href="constant.PROTOCOL_NAME.html" title="constant smoldot::libp2p::connection::noise::PROTOCOL_NAME"><code>PROTOCOL_NAME</code></a> constant.</p>
<p>In order to use noise on top of a connection which has agreed to use noise, create a
<a href="struct.HandshakeInProgress.html" title="struct smoldot::libp2p::connection::noise::HandshakeInProgress"><code>HandshakeInProgress</code></a>, passing a <a href="struct.NoiseKey.html" title="struct smoldot::libp2p::connection::noise::NoiseKey"><code>NoiseKey</code></a>. This <a href="struct.NoiseKey.html" title="struct smoldot::libp2p::connection::noise::NoiseKey"><code>NoiseKey</code></a> is typically generated at
startup and doesn’t need to be persisted after a restart.</p>
<p>Use <a href="struct.HandshakeInProgress.html#method.read_write" title="method smoldot::libp2p::connection::noise::HandshakeInProgress::read_write"><code>HandshakeInProgress::read_write</code></a> when data is received from the wire or when the remote
is ready to receive more data. At every call, a <a href="enum.NoiseHandshake.html" title="enum smoldot::libp2p::connection::noise::NoiseHandshake"><code>NoiseHandshake</code></a> is returned, potentially
indicating the end of the handshake.</p>
<p>If the handshake is finished, a <a href="enum.NoiseHandshake.html#variant.Success" title="variant smoldot::libp2p::connection::noise::NoiseHandshake::Success"><code>NoiseHandshake::Success</code></a> is returned, containing the
<a href="../../peer_id/struct.PeerId.html" title="struct smoldot::libp2p::peer_id::PeerId"><code>PeerId</code></a> of the remote, which is known to be legitimate, and a <a href="struct.Noise.html" title="struct smoldot::libp2p::connection::noise::Noise"><code>Noise</code></a> object through
which all further communications should go through.</p>
<p>Use <a href="struct.Noise.html#method.encrypt" title="method smoldot::libp2p::connection::noise::Noise::encrypt"><code>Noise::encrypt</code></a> in order to send out data to the remote, and
<a href="struct.Noise.html#method.inject_inbound_data" title="method smoldot::libp2p::connection::noise::Noise::inject_inbound_data"><code>Noise::inject_inbound_data</code></a> when data is received.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CipherError.html" title="struct smoldot::libp2p::connection::noise::CipherError">CipherError</a></div><div class="desc docblock-short">Error while decoding data.</div></li><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct smoldot::libp2p::connection::noise::Config">Config</a></div><div class="desc docblock-short">Configuration for a Noise handshake.</div></li><li><div class="item-name"><a class="struct" href="struct.HandshakeInProgress.html" title="struct smoldot::libp2p::connection::noise::HandshakeInProgress">HandshakeInProgress</a></div><div class="desc docblock-short">Handshake still in progress. More data needs to be sent or received.</div></li><li><div class="item-name"><a class="struct" href="struct.Noise.html" title="struct smoldot::libp2p::connection::noise::Noise">Noise</a></div><div class="desc docblock-short">State of the noise encryption/decryption cipher.</div></li><li><div class="item-name"><a class="struct" href="struct.NoiseKey.html" title="struct smoldot::libp2p::connection::noise::NoiseKey">NoiseKey</a></div><div class="desc docblock-short">The noise key is the key exchanged during the noise handshake. It is <strong>not</strong> the same as the
libp2p key. The libp2p key is used only to sign the noise public key, while the ECDH is
performed with the noise key.</div></li><li><div class="item-name"><a class="struct" href="struct.PayloadDecodeError.html" title="struct smoldot::libp2p::connection::noise::PayloadDecodeError">PayloadDecodeError</a></div><div class="desc docblock-short">Error while decoding the handshake.</div></li><li><div class="item-name"><a class="struct" href="struct.UnsignedNoiseKey.html" title="struct smoldot::libp2p::connection::noise::UnsignedNoiseKey">UnsignedNoiseKey</a></div><div class="desc docblock-short">Prototype for a <a href="struct.NoiseKey.html" title="struct smoldot::libp2p::connection::noise::NoiseKey"><code>NoiseKey</code></a>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.HandshakeError.html" title="enum smoldot::libp2p::connection::noise::HandshakeError">HandshakeError</a></div><div class="desc docblock-short">Potential error during the noise handshake.</div></li><li><div class="item-name"><a class="enum" href="enum.NoiseHandshake.html" title="enum smoldot::libp2p::connection::noise::NoiseHandshake">NoiseHandshake</a></div><div class="desc docblock-short">State of a Noise handshake.</div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.PROTOCOL_NAME.html" title="constant smoldot::libp2p::connection::noise::PROTOCOL_NAME">PROTOCOL_NAME</a></div><div class="desc docblock-short">Name of the protocol, typically used when negotiated it using <em>multistream-select</em>.</div></li></ul></section></div></main></body></html>