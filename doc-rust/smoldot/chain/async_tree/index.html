<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Performing asynchronous operations on blocks."><title>smoldot::chain::async_tree - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="smoldot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../smoldot/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../smoldot/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module async_tree</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">smoldot</a>::<wbr><a href="../index.html">chain</a>::<wbr><a class="mod" href="#">async_tree</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/smoldot/chain/async_tree.rs.html#18-1320">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Performing asynchronous operations on blocks.</p>
<h2 id="summary"><a href="#summary">Summary</a></h2>
<p>This module contains the <a href="struct.AsyncTree.html" title="struct smoldot::chain::async_tree::AsyncTree"><code>AsyncTree</code></a> data structure.</p>
<p>When a block is inserted in the data structure, it is added to the so-called “input tree” and
its status is marked as pending. The data structure then starts, for each block marked as
pending, an asynchronous operation (what this operation consists of is decided by the API
user). Once an asynchronous operation is successful, the status of the block is switched to
“finished”. The data structure then puts the blocks in the so-called “output tree”.</p>
<p>The output tree is consistent, meaning that if the asynchronous operation of a child finishes
before the one of its parent, the child will be added to the output tree only after its
parent has finished its operation.
Similarly, if a block is finalized in the input tree, it only gets finalized in the output
tree after all of its ancestors have all finished their asynchronous operations.</p>
<p>An example use case is: you insert block headers, then for each block you download its body,
and thus obtain as output a tree of block headers and bodies.</p>
<h2 id="details"><a href="#details">Details</a></h2>
<p>The <a href="struct.AsyncTree.html" title="struct smoldot::chain::async_tree::AsyncTree"><code>AsyncTree</code></a> data structure contains two trees of blocks: one input tree and one output
tree. The output tree is a subset of the input tree.</p>
<p>Each of the two trees (input and output) has the following properties:</p>
<ul>
<li>A finalized block.</li>
<li>A tree of non-finalized blocks that all descend from the finalized block.</li>
<li>A best block that can be either the finalized block or one of the non-finalized blocks.</li>
</ul>
<p>Furthermore, each block has the following properties:</p>
<ul>
<li>An opaque user data.</li>
<li>A status: pending, in progress, or finished. Once finished, an “asynchronous user data” is
also attached to the block. All the blocks of the output tree are always in the “finished”
state.</li>
</ul>
<p>At initialization, both the input and output trees are initialized to the same finalized
block (that is also the best block), and don’t have any non-finalized block.</p>
<h2 id="example"><a href="#example">Example</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>smoldot::chain::async_tree;
<span class="kw">use </span>std::time::{Instant, Duration};

<span class="kw">let </span><span class="kw-2">mut </span>tree = async_tree::AsyncTree::new(async_tree::Config {
    finalized_async_user_data: <span class="string">&quot;hello&quot;</span>,
    retry_after_failed: Duration::from_secs(<span class="number">5</span>),
    blocks_capacity: <span class="number">32</span>,
});

<span class="comment">// Insert a new best block, child of the finalized block.
// When doing so, we insert a &quot;user data&quot;, a value opaque to the tree and that can be
// retreived later. Here we pass &quot;my block&quot;.
</span><span class="kw">let </span>_my_block_index = tree.input_insert_block(<span class="string">&quot;my block&quot;</span>, <span class="prelude-val">None</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>);

<span class="comment">// When calling `next_necessary_async_op`, the tree now generates a new asynchronous
// operation id.
</span><span class="kw">let </span>async_op_id = <span class="kw">match </span>tree.next_necessary_async_op(<span class="kw-2">&amp;</span>Instant::now()) {
    async_tree::NextNecessaryAsyncOp::Ready(params) =&gt; {
        <span class="macro">assert_eq!</span>(params.block_index, _my_block_index);
        <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>params.block_user_data, <span class="string">&quot;my block&quot;</span>);
        params.id
    }
    async_tree::NextNecessaryAsyncOp::NotReady { when: <span class="kw">_ </span>} =&gt; {
        <span class="comment">// In this example, this variant can&#39;t be returned. In practice, however, you need
        // to call `next_necessary_async_op` again after `when`.
        </span><span class="macro">panic!</span>();
    }
};

<span class="comment">// The user is now responsible for performing this asynchronous operation.
// When it is finished, call `async_op_finished`.
// Just like when inserting a new block, we insert another &quot;user data&quot; in all the blocks that
// have this asynchronous operation associated to them.
</span>tree.async_op_finished(async_op_id, <span class="string">&quot;world&quot;</span>);

<span class="comment">// You can now advance the best and finalized block of the tree. Calling this function tries
// to update the tree to match the best and finalized block of the input, except that only
// blocks whose asynchronous operation is finished are considered.
</span><span class="kw">match </span>tree.try_advance_output() {
    <span class="prelude-val">Some</span>(async_tree::OutputUpdate::Block(block)) =&gt; {
        <span class="macro">assert_eq!</span>(block.index, _my_block_index);
        <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>block.user_data, <span class="string">&quot;my block&quot;</span>);
        <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>block.async_op_user_data, <span class="string">&quot;world&quot;</span>);
        <span class="macro">assert!</span>(block.is_new_best);
    }
    <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>() <span class="comment">// Unreachable in this example.
</span>}</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.NodeIndex"><code>pub use fork_tree::<a class="struct" href="../fork_tree/struct.NodeIndex.html" title="struct smoldot::chain::fork_tree::NodeIndex">NodeIndex</a>;</code></div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AsyncOpId.html" title="struct smoldot::chain::async_tree::AsyncOpId">AsyncOpId</a></div><div class="desc docblock-short">Identifier for an asynchronous operation in the <a href="struct.AsyncTree.html" title="struct smoldot::chain::async_tree::AsyncTree"><code>AsyncTree</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.AsyncOpParams.html" title="struct smoldot::chain::async_tree::AsyncOpParams">AsyncOpParams</a></div><div class="desc docblock-short">Information about an operation that must be started.</div></li><li><div class="item-name"><a class="struct" href="struct.AsyncTree.html" title="struct smoldot::chain::async_tree::AsyncTree">AsyncTree</a></div><div class="desc docblock-short">See <a href="..">the module-level documentation</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct smoldot::chain::async_tree::Config">Config</a></div><div class="desc docblock-short">Configuration for <a href="struct.AsyncTree.html#method.new" title="associated function smoldot::chain::async_tree::AsyncTree::new"><code>AsyncTree::new</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.InputIterItem.html" title="struct smoldot::chain::async_tree::InputIterItem">InputIterItem</a></div><div class="desc docblock-short">See <a href="struct.AsyncTree.html#method.input_output_iter_unordered" title="method smoldot::chain::async_tree::AsyncTree::input_output_iter_unordered"><code>AsyncTree::input_output_iter_unordered</code></a> and
<a href="struct.AsyncTree.html#method.input_output_iter_ancestry_order" title="method smoldot::chain::async_tree::AsyncTree::input_output_iter_ancestry_order"><code>AsyncTree::input_output_iter_ancestry_order</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.OutputUpdateBlock.html" title="struct smoldot::chain::async_tree::OutputUpdateBlock">OutputUpdateBlock</a></div><div class="desc docblock-short">See <a href="enum.OutputUpdate.html" title="enum smoldot::chain::async_tree::OutputUpdate"><code>OutputUpdate</code></a>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.NextNecessaryAsyncOp.html" title="enum smoldot::chain::async_tree::NextNecessaryAsyncOp">NextNecessaryAsyncOp</a></div></li><li><div class="item-name"><a class="enum" href="enum.OutputUpdate.html" title="enum smoldot::chain::async_tree::OutputUpdate">OutputUpdate</a></div><div class="desc docblock-short">See <a href="struct.AsyncTree.html#method.try_advance_output" title="method smoldot::chain::async_tree::AsyncTree::try_advance_output"><code>AsyncTree::try_advance_output</code></a>.</div></li></ul></section></div></main></body></html>