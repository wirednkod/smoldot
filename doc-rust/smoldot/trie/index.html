<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Radix-16 Merkle-Patricia trie."><title>smoldot::trie - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="smoldot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../smoldot/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../smoldot/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module trie</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">smoldot</a>::<wbr><a class="mod" href="#">trie</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/smoldot/trie.rs.html#18-329">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Radix-16 Merkle-Patricia trie.</p>
<p>This Substrate/Polkadot-specific radix-16 Merkle-Patricia trie is a data structure that
associates keys with values, and that allows efficient verification of the integrity of the
data.</p>
<h2 id="overview"><a href="#overview">Overview</a></h2>
<p>The key-value storage that the blockchain maintains is represented by
<a href="https://en.wikipedia.org/wiki/Tree_data_structure">a tree</a>, where each key-value pair in the
storage corresponds to a node in that tree.</p>
<p>Each node in this tree has what is called a Merkle value associated to it. This Merkle value
consists, in its essence, in the combination of the storage value associated to that node and
the Merkle values of all of the node’s children. If the resulting Merkle value would be too
long, it is first hashed.</p>
<p>Since the Merkle values of a node’s children depend, in turn, of the Merkle value of their
own children, we can say that the Merkle value of a node depends on all of the node’s
descendants.</p>
<p>Consequently, the Merkle value of the root node of the tree depends on the storage values of
all the nodes in the tree.</p>
<p>See also <a href="https://en.wikipedia.org/wiki/Merkle_tree">the Wikipedia page for Merkle tree for a different
explanation</a>.</p>
<h3 id="efficient-updates"><a href="#efficient-updates">Efficient updates</a></h3>
<p>When a storage value gets modified, the Merkle value of the root node of the tree also gets
modified. Thanks to the tree layout, we don’t need to recalculate the Merkle value of the
entire tree, but only of the ancestors of the node which has been modified.</p>
<p>If the storage consists of N entries, recalculating the Merkle value of the trie root requires
on average only <code>log16(N)</code> operations.</p>
<h3 id="proof-of-storage-entry"><a href="#proof-of-storage-entry">Proof of storage entry</a></h3>
<p>In the situation where we want to know the storage value associated to a node, but we only
know the Merkle value of the root of the trie, it is possible to ask a third-party for the
unhashed Merkle values of the desired node and all its ancestors. This is called a Merkle
proof.</p>
<p>After having verified that the third-party has provided correct values, and that they match
the expected root node Merkle value known locally, we can extract the storage value from the
Merkle value of the desired node.</p>
<h2 id="details"><a href="#details">Details</a></h2>
<p>This data structure is a tree composed of nodes, each node being identified by a key. A key
consists in a sequence of 4-bits values called <em>nibbles</em>. Example key: <code>[3, 12, 7, 0]</code>.</p>
<p>Some of these nodes contain a value.</p>
<p>A node A is an <em>ancestor</em> of another node B if the key of A is a prefix of the key of B. For
example, the node whose key is <code>[3, 12]</code> is an ancestor of the node whose key is
<code>[3, 12, 8, 9]</code>. B is a <em>descendant</em> of A.</p>
<p>Nodes exist only either if they contain a value, or if their key is the longest shared prefix
of two or more nodes that contain a value. For example, if nodes <code>[7, 2, 9, 11]</code> and
<code>[7, 2, 14, 8]</code> contain a value, then node <code>[7, 2]</code> also exist, because it is the longest
prefix shared between the two.</p>
<p>The <em>Merkle value</em> of a node is composed, amongst other things, of its associated value and of
the Merkle value of its descendants. As such, modifying a node modifies the Merkle value of
all its ancestors. Note, however, that modifying a node modifies the Merkle value of <em>only</em>
its ancestors. As such, the time spent calculating the Merkle value of the root node of a trie
mostly depends on the number of modifications that are performed on it, and only a bit on the
size of the trie.</p>
<h3 id="trie-entry-version"><a href="#trie-entry-version">Trie entry version</a></h3>
<p>In the Substrate/Polkadot trie, each trie node that contains a value also has a version
associated to it.</p>
<p>This version changes the way the hash of the node is calculated and how the Merkle proof is
generated. Version 1 leads to more succinct Merkle proofs, which is important when these proofs
are sent over the Internet.</p>
<p>Note that most of the time all the entries of the trie have the same version. However, it is
possible for the trie to be in a hybrid state where some entries have a certain version and
other entries a different version. For this reason, most of the trie-related APIs require you
to provide a trie entry version alongside with the value.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="branch_search/index.html" title="mod smoldot::trie::branch_search">branch_search</a></div><div class="desc docblock-short">Allows searching for the closest branch node in a trie when only the storage trie nodes are
known.</div></li><li><div class="item-name"><a class="mod" href="calculate_root/index.html" title="mod smoldot::trie::calculate_root">calculate_root</a></div><div class="desc docblock-short">Freestanding function that calculates the root of a radix-16 Merkle-Patricia trie.</div></li><li><div class="item-name"><a class="mod" href="prefix_proof/index.html" title="mod smoldot::trie::prefix_proof">prefix_proof</a></div><div class="desc docblock-short">Scanning, through trie proofs, the list of all keys that share a certain prefix.</div></li><li><div class="item-name"><a class="mod" href="proof_decode/index.html" title="mod smoldot::trie::proof_decode">proof_decode</a></div><div class="desc docblock-short">Decodes and verifies a trie proof.</div></li><li><div class="item-name"><a class="mod" href="proof_encode/index.html" title="mod smoldot::trie::proof_encode">proof_encode</a></div></li><li><div class="item-name"><a class="mod" href="trie_node/index.html" title="mod smoldot::trie::trie_node">trie_node</a></div></li><li><div class="item-name"><a class="mod" href="trie_structure/index.html" title="mod smoldot::trie::trie_structure">trie_structure</a></div><div class="desc docblock-short">Manages the structure of a trie. Allows inserting and removing nodes, but does not store any
value. Only the structure is stored.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BytesToNibbles.html" title="struct smoldot::trie::BytesToNibbles">BytesToNibbles</a></div><div class="desc docblock-short">Turns an iterator of bytes into an iterator of nibbles corresponding to these bytes.</div></li><li><div class="item-name"><a class="struct" href="struct.Nibble.html" title="struct smoldot::trie::Nibble">Nibble</a></div><div class="desc docblock-short">A single nibble with four bits.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.NibbleFromU8Error.html" title="enum smoldot::trie::NibbleFromU8Error">NibbleFromU8Error</a></div><div class="desc docblock-short">Error when building a <a href="proof_encode/struct.Nibble.html" title="struct smoldot::trie::proof_encode::Nibble"><code>Nibble</code></a> from a <code>u8</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.TrieEntryVersion.html" title="enum smoldot::trie::TrieEntryVersion">TrieEntryVersion</a></div><div class="desc docblock-short">The format of the nodes of trie has two different versions.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.all_nibbles.html" title="fn smoldot::trie::all_nibbles">all_nibbles</a></div><div class="desc docblock-short">Returns an iterator of all possible nibble values, in ascending order.</div></li><li><div class="item-name"><a class="fn" href="fn.bytes_to_nibbles.html" title="fn smoldot::trie::bytes_to_nibbles">bytes_to_nibbles</a></div><div class="desc docblock-short">Turns an iterator of bytes into an iterator of nibbles corresponding to these bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.empty_trie_merkle_value.html" title="fn smoldot::trie::empty_trie_merkle_value">empty_trie_merkle_value</a></div><div class="desc docblock-short">Returns the Merkle value of the root of an empty trie.</div></li><li><div class="item-name"><a class="fn" href="fn.nibbles_to_bytes_prefix_extend.html" title="fn smoldot::trie::nibbles_to_bytes_prefix_extend">nibbles_to_bytes_prefix_extend</a></div><div class="desc docblock-short">Turns an iterator of nibbles into an iterator of bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.nibbles_to_bytes_suffix_extend.html" title="fn smoldot::trie::nibbles_to_bytes_suffix_extend">nibbles_to_bytes_suffix_extend</a></div><div class="desc docblock-short">Turns an iterator of nibbles into an iterator of bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.nibbles_to_bytes_truncate.html" title="fn smoldot::trie::nibbles_to_bytes_truncate">nibbles_to_bytes_truncate</a></div><div class="desc docblock-short">Turns an iterator of nibbles into an iterator of bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.ordered_root.html" title="fn smoldot::trie::ordered_root">ordered_root</a></div><div class="desc docblock-short">Returns the Merkle value of a trie containing the entries passed as parameter, where the keys
are the SCALE-codec-encoded indices of these entries.</div></li><li><div class="item-name"><a class="fn" href="fn.trie_root.html" title="fn smoldot::trie::trie_root">trie_root</a></div><div class="desc docblock-short">Returns the Merkle value of a trie containing the entries passed as parameter. The entries
passed as parameter are <code>(key, value)</code>.</div></li></ul></section></div></main></body></html>