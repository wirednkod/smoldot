<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `RequestsSubscriptions` state machine holds a list of clients, pending outgoing messages, pending requests, and active subscriptions."><title>smoldot::json_rpc::requests_subscriptions - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="smoldot" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../smoldot/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../smoldot/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module requests_subscriptions</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">smoldot</a>::<wbr><a href="../index.html">json_rpc</a>::<wbr><a class="mod" href="#">requests_subscriptions</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/smoldot/json_rpc/requests_subscriptions.rs.html#18-1377">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <a href="struct.RequestsSubscriptions.html" title="struct smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions"><code>RequestsSubscriptions</code></a> state machine holds a list of clients, pending outgoing messages,
pending requests, and active subscriptions.</p>
<p>The code in this module is the front line of the JSON-RPC server. It can be subject to DoS
attacks, and is therefore designed to properly distribute resources between JSON-RPC clients.
If you use this data structure as intended, your design is safe from DoS attacks.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>The <a href="struct.RequestsSubscriptions.html" title="struct smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions"><code>RequestsSubscriptions</code></a> is meant to be shared (through an <code>Arc</code> or similar) between many
different asynchronous tasks that call its methods.</p>
<blockquote>
<p><strong>Note</strong>: While off-topic for this module, you are strongly encouraged to put all these
asynchronous tasks within a single <code>FuturesUnordered</code>. This ensure that no two
tasks can be processed at the same time, and thus limits the total CPU usage of
all these tasks combined to <code>1.0</code> CPU cores. This leaves other CPU cores free for
the more urgent processing.</p>
</blockquote>
<p>There should be:</p>
<ul>
<li>One lightweight task for each client currently connected to the server.</li>
<li>A fixed number of lightweight tasks (e.g. 16) dedicated to answering requests.</li>
<li>A fixed number of lightweight tasks (e.g. 8) dedicated to processing subscription tasks by
calling <a href="struct.RequestsSubscriptions.html#method.run_subscription_task" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::run_subscription_task"><code>RequestsSubscriptions::run_subscription_task</code></a> in a loop.</li>
</ul>
<h3 id="clients"><a href="#clients">Clients</a></h3>
<p>Whenever a new client connects to the server, spawn a new task dedicated to this client, that:</p>
<ul>
<li>Calls <a href="struct.RequestsSubscriptions.html#method.add_client" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::add_client"><code>RequestsSubscriptions::add_client</code></a>, denying the client if the function returns an
error.</li>
<li>Repeatedly polls the socket for a new request then calls
<a href="struct.RequestsSubscriptions.html#method.queue_client_request" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::queue_client_request"><code>RequestsSubscriptions::queue_client_request</code></a>.</li>
<li>At the same time (for example in a <code>select!</code> block) calls
<a href="struct.RequestsSubscriptions.html#method.next_response" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::next_response"><code>RequestsSubscriptions::next_response</code></a> then sends the response to the socket.</li>
<li>When the client disconnects, calls <a href="struct.RequestsSubscriptions.html#method.remove_client" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::remove_client"><code>RequestsSubscriptions::remove_client</code></a>.</li>
</ul>
<p>It is important that no new request is polled from the socket as long as
<a href="struct.RequestsSubscriptions.html#method.queue_client_request" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::queue_client_request"><code>RequestsSubscriptions::queue_client_request</code></a> hasn’t been able to queue the previous
request. This makes it possible to back-pressure the JSON-RPC client in case when the queue
is slow to be processed.</p>
<p>Similarly, do not call <a href="struct.RequestsSubscriptions.html#method.next_response" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::next_response"><code>RequestsSubscriptions::next_response</code></a> before the socket has been
able to send the previous response. Not calling <a href="struct.RequestsSubscriptions.html#method.next_response" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::next_response"><code>RequestsSubscriptions::next_response</code></a> often
enough will lead to back-pressure being applied onto
<a href="struct.RequestsSubscriptions.html#method.queue_client_request" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::queue_client_request"><code>RequestsSubscriptions::queue_client_request</code></a>, which will in turn back-pressure the sending
side of the JSON-RPC client.</p>
<p>Note that if a client is removed at the same time as a call to
<a href="struct.RequestsSubscriptions.html#method.next_response" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::next_response"><code>RequestsSubscriptions::next_response</code></a> is in progress, the call will never return  It is
your responsibility to interrupt this function call when the client is disconnected. If,
as advised above, everything is contained within a single task, this is normally not a problem
as you simply stop the task altogether after removing the client.</p>
<h3 id="requests"><a href="#requests">Requests</a></h3>
<p>There should be a certain, fixed, number of lightweight tasks dedicated to pulling requests
from the state machine and answering them.</p>
<p>Each of these lightweight tasks should:</p>
<ul>
<li>Call <a href="struct.RequestsSubscriptions.html#method.next_request" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::next_request"><code>RequestsSubscriptions::next_request</code></a>. This function call sleeps until there is a
request available.</li>
<li>Parse the request that was returned and generate its response. This step should be relatively
fast (e.g. not more than one second), but can liberally perform asynchronous requests, lock
mutexes, etc.</li>
<li>Call <a href="struct.RequestsSubscriptions.html#method.respond" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::respond"><code>RequestsSubscriptions::respond</code></a>.</li>
<li>Jump back to step 1.</li>
</ul>
<p>If these tasks are too busy and don’t call <a href="struct.RequestsSubscriptions.html#method.next_request" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::next_request"><code>RequestsSubscriptions::next_request</code></a> often
enough, back-pressure will be applied onto <a href="struct.RequestsSubscriptions.html#method.queue_client_request" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::queue_client_request"><code>RequestsSubscriptions::queue_client_request</code></a>,
which in turn applies back-pressure onto the JSON-RPC clients.</p>
<h3 id="subscriptions"><a href="#subscriptions">Subscriptions</a></h3>
<p>If a client-sent request requires starting a subscription, one of the
requests-pulling-dedicated tasks should call <a href="struct.RequestsSubscriptions.html#method.start_subscription" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::start_subscription"><code>RequestsSubscriptions::start_subscription</code></a>.</p>
<p>When a subscription is started, the higher-level code spawns a new task dedicated to
sending back notifications to the client using <a href="struct.RequestsSubscriptions.html#method.push_notification" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::push_notification"><code>RequestsSubscriptions::push_notification</code></a>,
<a href="struct.RequestsSubscriptions.html#method.try_push_notification" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::try_push_notification"><code>RequestsSubscriptions::try_push_notification</code></a>, or
<a href="struct.RequestsSubscriptions.html#method.set_queued_notification" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::set_queued_notification"><code>RequestsSubscriptions::set_queued_notification</code></a>.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="executor/index.html" title="mod smoldot::json_rpc::requests_subscriptions::executor">executor</a></div><div class="desc docblock-short">FIFO queue of futures.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ClientId.html" title="struct smoldot::json_rpc::requests_subscriptions::ClientId">ClientId</a></div></li><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct smoldot::json_rpc::requests_subscriptions::Config">Config</a></div><div class="desc docblock-short">Configuration to pass to <a href="struct.RequestsSubscriptions.html#method.new" title="associated function smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::new"><code>RequestsSubscriptions::new</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ConfirmationSend.html" title="struct smoldot::json_rpc::requests_subscriptions::ConfirmationSend">ConfirmationSend</a></div><div class="desc docblock-short">Provided by the <a href="struct.MessagesReceiver.html" title="struct smoldot::json_rpc::requests_subscriptions::MessagesReceiver"><code>MessagesReceiver</code></a> in the context of a subscription receiving a message.</div></li><li><div class="item-name"><a class="struct" href="struct.MessagesReceiver.html" title="struct smoldot::json_rpc::requests_subscriptions::MessagesReceiver">MessagesReceiver</a></div><div class="desc docblock-short">Provided when a subscription is started. Allows receiving the messages that were sent using
<a href="struct.RequestsSubscriptions.html#method.subscription_send" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::subscription_send"><code>RequestsSubscriptions::subscription_send</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RequestId.html" title="struct smoldot::json_rpc::requests_subscriptions::RequestId">RequestId</a></div></li><li><div class="item-name"><a class="struct" href="struct.RequestsSubscriptions.html" title="struct smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions">RequestsSubscriptions</a></div></li><li><div class="item-name"><a class="struct" href="struct.SubscriptionStart.html" title="struct smoldot::json_rpc::requests_subscriptions::SubscriptionStart">SubscriptionStart</a></div><div class="desc docblock-short">Returned by <a href="struct.RequestsSubscriptions.html#method.start_subscription" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::start_subscription"><code>RequestsSubscriptions::start_subscription</code></a> when a subscription is ready to be
started.</div></li><li><div class="item-name"><a class="struct" href="struct.TryQueueClientRequestError.html" title="struct smoldot::json_rpc::requests_subscriptions::TryQueueClientRequestError">TryQueueClientRequestError</a></div><div class="desc docblock-short">Error returned by <a href="struct.RequestsSubscriptions.html#method.try_queue_client_request" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::try_queue_client_request"><code>RequestsSubscriptions::try_queue_client_request</code></a>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AddClientError.html" title="enum smoldot::json_rpc::requests_subscriptions::AddClientError">AddClientError</a></div><div class="desc docblock-short">Error returned by <a href="struct.RequestsSubscriptions.html#method.add_client" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::add_client"><code>RequestsSubscriptions::add_client</code></a> and
<a href="struct.RequestsSubscriptions.html#method.add_client_mut" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::add_client_mut"><code>RequestsSubscriptions::add_client_mut</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.ClientOrRequestIdRef.html" title="enum smoldot::json_rpc::requests_subscriptions::ClientOrRequestIdRef">ClientOrRequestIdRef</a></div></li><li><div class="item-name"><a class="enum" href="enum.StartSubscriptionError.html" title="enum smoldot::json_rpc::requests_subscriptions::StartSubscriptionError">StartSubscriptionError</a></div><div class="desc docblock-short">Error returned by <a href="struct.RequestsSubscriptions.html#method.start_subscription" title="method smoldot::json_rpc::requests_subscriptions::RequestsSubscriptions::start_subscription"><code>RequestsSubscriptions::start_subscription</code></a>.</div></li></ul></section></div></main></body></html>